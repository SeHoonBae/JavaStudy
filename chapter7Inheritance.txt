super()는 반드시 자식 생성자 첫 줄에 위치해야 한다.

오버라이딩된 부모 메소드를 super.부모메소드();로 접근할 수 있다.

final 클래스는 상속 X, final 메소드는 오버라이딩 X, final 필드는 수정 X

다른패키지에 있는 자식 클래스는 부모클래스의 protected 필드,생성자,메소드에 접근 가능하지만 new연산자를 사용해서 생성자를 직접 호출할 수 없고 자식 생성자에서 super()로 부모 생성자를 호출할 수 있다.
즉 new 연산자를 쓰는것만 불가능하고 나머지는 됨

부모클래스 변수 = 자식클래스타입;
ex) Cat cat = new Cat();
Animal animal = cat; 	->Animal이 부모클래스 Cat이 자식 클래스
Tire t1 = new HankookTire(); 	-> Tire가 부모클래스 HankookTire가 자식클래스

부모타입으로 자동타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다
메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 대신 호출된다

해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.
매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다(매개변수의 다형성)

자식 타입이 부모타입으로 자동변환 후 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용한다.
강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.
ex) 자식클래스 변수 = (자식클래스) 부모클래스타입;
Parent parent = new Child();	-> Parent가 부모 Child가 자식
Child child = (Child) parent;

instanceof 연산자는 매개값의 타입을 조사할 때 사용
메소드 내에서 강제 타입 변환이 필요할 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야한다.
ex) boolean result = 좌항(객체) instanceof 우항(타입)
parent instanceof Child
















